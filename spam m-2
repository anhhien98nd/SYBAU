-- ‚öôÔ∏è Auto Spam M1 (Optimized Lightweight)
-- √Åp d·ª•ng nguy√™n t·∫Øc: gi·ªõi h·∫°n thread, cleanup b·ªô nh·ªõ, an to√†n & nh·∫π CPU

local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- ‚öôÔ∏è C·∫•u h√¨nh
local FIRE_INTERVAL = 0.4 -- gi√¢y gi·ªØa m·ªói l·∫ßn g·ª≠i
local SCHEDULE = {
    {72, 76},
    {95, 99},
    {116, 120},
}

-- ‚öôÔ∏è T√¨m remote
local remote
pcall(function()
    local bridge = ReplicatedStorage:FindFirstChild("BridgeNet2")
    if bridge then
        remote = bridge:FindFirstChild("dataRemoteEvent")
    end
    if not remote then
        for _, v in ipairs(ReplicatedStorage:GetDescendants()) do
            if v.Name == "dataRemoteEvent" then
                remote = v
                break
            end
        end
    end
end)

-- ‚öôÔ∏è buffer handler
local bf = (type(buffer) == "table" and type(buffer.fromstring) == "function")
    and buffer.fromstring
    or function(s) return s end

local PAYLOAD = "\019\000\000\0000201000113686372022\000"

-- ‚öôÔ∏è Tr·∫°ng th√°i qu·∫£n l√Ω script
local AutoSpam = {
    active = false,
    thread = nil,
    tick0 = tick(),
}

-- üßπ H√†m cleanup
function AutoSpam:Stop()
    if not self.active then return end
    self.active = false

    if self.thread and coroutine.close then
        pcall(function() coroutine.close(self.thread) end)
    end
    self.thread = nil

    pcall(function() collectgarbage("collect") end)
    print("[Auto Spam M1] üî¥ D·ª´ng & d·ªçn d·∫πp ho√†n t·∫•t.")
end

-- ‚öôÔ∏è H√†m g·ª≠i an to√†n
local function safeFire()
    if not remote then
        if not safeFire._warned then
            warn("[Auto Spam M1] ‚ö†Ô∏è remote kh√¥ng kh·∫£ d·ª•ng.")
            safeFire._warned = true
        end
        return
    end
    pcall(function()
        remote:FireServer({ { bf(PAYLOAD) }, "\019" })
    end)
end

-- ‚öôÔ∏è Thread ch√≠nh: ch·∫°y tu·∫ßn t·ª± to√†n b·ªô schedule
local function StartAutoSpam()
    if AutoSpam.active then
        warn("[Auto Spam M1] ƒêang ho·∫°t ƒë·ªông ‚Äî b·ªè qua l·∫ßn kh·ªüi ƒë·ªông tr√πng.")
        return
    end
    AutoSpam.active = true
    AutoSpam.tick0 = tick()

    print(("[Auto Spam M1] üü¢ B·∫Øt ƒë·∫ßu Auto Spam (%d kho·∫£ng th·ªùi gian)."):format(#SCHEDULE))

    AutoSpam.thread = coroutine.create(function()
        for i, window in ipairs(SCHEDULE) do
            if not AutoSpam.active then break end

            local startSec, endSec = window[1], window[2]
            if type(startSec) ~= "number" or type(endSec) ~= "number" or endSec <= startSec then
                warn(("[Auto Spam M1] ‚ö†Ô∏è Schedule #%d kh√¥ng h·ª£p l·ªá."):format(i))
                continue
            end

            local startTime = AutoSpam.tick0 + startSec
            local endTime = AutoSpam.tick0 + endSec

            -- üïí ƒê·ª£i t·ªõi th·ªùi ƒëi·ªÉm b·∫Øt ƒë·∫ßu
            local toWait = startTime - tick()
            if toWait > 0 then
                task.wait(toWait)
            end

            if tick() >= endTime then
                warn(("[Auto Spam M1] ‚è© Schedule #%d ƒë√£ qua, b·ªè qua."):format(i))
                continue
            end

            print(("[Auto Spam M1] üîπ B·∫ÆT ƒê·∫¶U #%d (%.1fs ‚Üí %.1fs)"):format(i, startSec, endSec))

            while AutoSpam.active and tick() < endTime do
                safeFire()
                task.wait(FIRE_INTERVAL)
            end

            print(("[Auto Spam M1] üî∏ K·∫æT TH√öC #%d (%.1fs)").format(i, endSec))
        end

        AutoSpam:Stop()
    end)

    task.spawn(function()
        coroutine.resume(AutoSpam.thread)
    end)
end

-- üü¢ T·ª± kh·ªüi ƒë·ªông
StartAutoSpam()

-- üõë D·ª´ng th·ªß c√¥ng n·∫øu c·∫ßn
getgenv().StopAutoSpamM1 = function()
    AutoSpam:Stop()
end
