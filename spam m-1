-- ‚öôÔ∏è Auto Spam M1 (Optimized + Lightweight)
-- G·ª≠i l·ªánh theo l·ªãch, c√≥ cleanup, kh√¥ng l√†m n·∫∑ng m√°y
-- √Åp d·ª•ng nguy√™n t·∫Øc: gi·ªõi h·∫°n thread, qu·∫£n l√Ω b·ªô nh·ªõ, pcall an to√†n

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local FIRE_INTERVAL = 0.4 -- kho·∫£ng c√°ch gi·ªØa m·ªói l·∫ßn g·ª≠i (gi√¢y)
local SCHEDULE = {
    {61, 65},
    {84, 88},
    {106, 110},
}

-- üß† T√¨m remote an to√†n
local remote
pcall(function()
    local bridge = ReplicatedStorage:FindFirstChild("BridgeNet2")
    if bridge then
        remote = bridge:FindFirstChild("dataRemoteEvent")
    end
    if not remote then
        for _, v in ipairs(ReplicatedStorage:GetDescendants()) do
            if v.Name == "dataRemoteEvent" then
                remote = v
                break
            end
        end
    end
end)

-- üß© buffer.fromstring fallback
local bf = (type(buffer) == "table" and type(buffer.fromstring) == "function")
    and buffer.fromstring
    or function(s) return s end

local PAYLOAD = "\019\000\000\0000201000113686372022\000"

-- üß± Tr·∫°ng th√°i script
local AutoSpam = {
    active = false,
    thread = nil,
    startTick = tick(),
}

-- üßπ Cleanup function
function AutoSpam:Stop()
    if not self.active then return end
    self.active = false

    if self.thread and coroutine.close then
        pcall(function() coroutine.close(self.thread) end)
    end
    self.thread = nil

    pcall(function() collectgarbage("collect") end)
    print("[Auto Spam M1] üî¥ ƒê√£ d·ª´ng & d·ªçn d·∫πp ho√†n t·∫•t.")
end

-- ‚öôÔ∏è H√†m g·ª≠i l·ªánh an to√†n
local function safeFire()
    if not remote then
        if not safeFire._warned then
            warn("[Auto Spam M1] ‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y remote dataRemoteEvent.")
            safeFire._warned = true
        end
        return
    end
    pcall(function()
        remote:FireServer({ { bf(PAYLOAD) }, "\019" })
    end)
end

-- ‚öôÔ∏è H√†m ch√≠nh: qu·∫£n l√Ω to√†n b·ªô schedule trong 1 thread
local function StartAutoSpam()
    if AutoSpam.active then
        warn("[Auto Spam M1] ƒê√£ ch·∫°y r·ªìi ‚Äî b·ªè qua l·∫ßn kh·ªüi ƒë·ªông tr√πng.")
        return
    end
    AutoSpam.active = true
    AutoSpam.startTick = tick()

    print("[Auto Spam M1] üü¢ Kh·ªüi ƒë·ªông Auto Spam (t·ªïng " .. #SCHEDULE .. " kho·∫£ng th·ªùi gian).")

    AutoSpam.thread = coroutine.create(function()
        for i, win in ipairs(SCHEDULE) do
            if not AutoSpam.active then break end
            local startSec, endSec = win[1], win[2]

            if type(startSec) ~= "number" or type(endSec) ~= "number" or endSec <= startSec then
                warn(("[Auto Spam M1] ‚ö†Ô∏è Schedule #%d kh√¥ng h·ª£p l·ªá ‚Äî b·ªè qua."):format(i))
                continue
            end

            local startTime = AutoSpam.startTick + startSec
            local endTime = AutoSpam.startTick + endSec

            local waitTime = startTime - tick()
            if waitTime > 0 then
                task.wait(waitTime)
            end

            if tick() >= endTime then
                warn(("[Auto Spam M1] ‚ö†Ô∏è Schedule #%d tr·ªÖ ‚Äî b·ªè qua."):format(i))
                continue
            end

            print(("[Auto Spam M1] üîπ B·∫ÆT ƒê·∫¶U #%d (%.1fs ‚Üí %.1fs)"):format(i, startSec, endSec))

            while AutoSpam.active and tick() < endTime do
                safeFire()
                task.wait(FIRE_INTERVAL)
            end

            print(("[Auto Spam M1] üî∏ K·∫æT TH√öC #%d (%.1fs)").format(i, endSec))
        end

        AutoSpam:Stop()
    end)

    task.spawn(function()
        coroutine.resume(AutoSpam.thread)
    end)
end

-- üü¢ Kh·ªüi ƒë·ªông ngay
StartAutoSpam()

-- üõë D·ª´ng th·ªß c√¥ng
getgenv().StopAutoSpamM1 = function()
    AutoSpam:Stop()
end
